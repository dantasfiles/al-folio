---
---

@inproceedings{10.1145/1599410.1599440,
  abbr = {PPDP},
  author = {Kenny Zhu and Daniel Dantas and Kathleen Fisher and Limin Jia and Yitzhak Mandelbaum and Vivek Pai and David Walker},
  title = {Language support for processing distributed ad hoc data},
  year = {2009},
  month = {sep},
  isbn = {9781605585680},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1599410.1599440},
  html = {https://doi.org/10.1145/1599410.1599440},
  doi = {10.1145/1599410.1599440},
  abstract = {This paper presents the design, theory and implementation of Gloves, a domain-specific language that allows users to specify the provenance (the derivation history starting from the origins), syntax and semantic properties of collections of distributed data sources. In particular, Gloves specifications indicate where to locate desired data, how to obtain it, when to get it or to give up trying, and what format it will be in on arrival. The Gloves system compiles such specification into a suite of data-processing tools including an archiver, a provenance tracking system, a database loading tool, an alert system, an RSS feed generator and a debugging tool. In addition, the system generates description-specific libraries so that developers can create their own applications. Gloves also provides a generic infrastructure so that advanced users can build new tools applicable to any data source with a Gloves description. We show how Gloves may be used to specify data sources from two domains: CoMon, a monitoring system for PlanetLab's 800+ nodes, and Arrakis, a monitoring system for an AT&T web hosting service. We show experimentally that our system can scale to distributed systems the size of CoMon. Finally, we provide a denotational semantics for Gloves and use this semantics to prove two important theorems. The first shows that our denotational semantics respects the typing rules for the language, while the second demonstrates that our system correctly maintains the provenance.},
  booktitle = {the ACM SIGPLAN Conference on Principles and Practice of Declarative Programming},
  pages = {243–254},
  numpages = {12},
  keywords = {distributed data sources, declarative language},
  location = {Coimbra, Portugal},
  series = {PPDP '09}
}

@article{10.1145/1353445.1353448,
  abbr = {TOPLAS},
  author = {Daniel Dantas and David Walker and Geoffrey Washburn and Stephanie Weirich},
  title = {AspectML: A polymorphic aspect-oriented functional programming language},
  year = {2008},
  issue_date = {May 2008},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {30},
  number = {3},
  issn = {0164-0925},
  url = {https://doi.org/10.1145/1353445.1353448},
  html = {https://doi.org/10.1145/1353445.1353448},
  doi = {10.1145/1353445.1353448},
  abstract = {This article defines AspectML, a typed functional, aspect-oriented programming language. The main contribution of AspectML is the seamless integration of polymorphism, run-time type analysis and aspect-oriented programming language features. In particular, AspectML allows programmers to define type-safe polymorphic advice using pointcuts constructed from a collection of polymorphic join points. AspectML also comes equipped with a type inference algorithm that conservatively extends Hindley--Milner type inference. To support first-class polymorphic point-cut designators, a crucial feature for developing aspect-oriented profiling or logging libraries, the algorithm blends the conventional Hindley--Milner type inference algorithm with a simple form of local type inference.We give our language operational meaning via a type-directed translation into an expressive type-safe intermediate language. Many complexities of the source language are eliminated in this translation, leading to a modular specification of its semantics. One of the novelties of the intermediate language is the definition of polymorphic labels for marking control-flow points. When a set of labels is assembled as a pointcut, the type of each label is an instance of the type of the pointcut.},
  journal = {ACM Transactions on Programming Languages and Systems},
  month = {may},
  articleno = {14},
  numpages = {60},
  keywords = {Aspect-oriented programming, functional languages, parametric and ad-hoc polymorphism, type inference, type systems},
  code = {https://github.com/dantasfiles/AspectML}
}

@inproceedings{10.1145/1314436.1314439,
  abbr = {FMSE},
  author = {Glenn Bruns and Daniel Dantas and Michael Huth},
  title = {A simple and expressive semantic framework for policy composition in access control},
  year = {2007},
  month = {nov},
  isbn = {9781595938879},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1314436.1314439},
  html = {https://doi.org/10.1145/1314436.1314439},
  doi = {10.1145/1314436.1314439},
  abstract = {In defining large, complex access control policies, one would like to compose sub-policies, perhaps authored by different organizations, into a single global policy. Existing policy composition approaches tend to be ad-hoc, and do not explain whether too many or too few policy combinators have been defined. We define an access controlpolicy as a four-valued predicate that maps accesses to either grant, deny, conflict, or unspecified. These correspond to the four elements of the Belnap bilattice. Functions on this bilattice are then extended to policies to serve as policy combinators. We argue that this approach provides a simple andnatural semantic framework for policy composition, with a minimal but functionally complete set of policy combinators. We define derived, higher-level operators that are convenient for the specification of access control policies, and enable the decoupling of conflict resolution from policy composition. Finally, we propose a basic query language and show that it can reduce important analyses (e.g., conflict analysis) to checks of policy refinement.},
  booktitle = {the ACM Workshop on Formal Methods in Security Engineering},
  pages = {12–21},
  numpages = {10},
  keywords = {access-control policy languages, bilattices, multi-valued logic},
  location = {Fairfax, Virginia, USA},
  series = {FMSE '07},
  code = {https://github.com/dantasfiles/Aspects-of-Access-Control}
}

@phdthesis{dantasfiles,
  abbr = {PRINCETON},
  author = {Daniel Dantas},
  year = {2007},
  month = {sep},
  title = {Analyzing security advice in functional aspect-oriented programming languages},
  school = {Princeton Ph.D Thesis},
  html = {https://www.cs.princeton.edu/research/techreps/TR-795-07},
  abstract = {This thesis extends functional programming languages with aspect-oriented features, primarily to explore aspect-oriented enforcement of security policies.}
}

@inproceedings{10.1145/1111037.1111071,
  abbr = {POPL},
  author = {Daniel Dantas and David Walker},
  title = {Harmless advice},
  year = {2006},
  month = {jan},
  isbn = {1595930272},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1111037.1111071},
  html = {https://doi.org/10.1145/1111037.1111071},
  doi = {10.1145/1111037.1111071},
  abstract = {This paper defines an object-oriented language with harmless aspect-oriented advice. A piece of harmless advice is a computation that, like ordinary aspect-oriented advice, executes when control reaches a designated control-flow point. However, unlike ordinary advice, harmless advice is designed to obey a weak non-interference property. Harmless advice may change the termination behavior of computations and use I/O, but it does not otherwise influence the final result of the mainline code. The benefit of harmless advice is that it facilitates local reasoning about program behavior. More specifically, programmers may ignore harmless advice when reasoning about the partial correctness properties of their programs. In addition, programmers may add new pieces of harmless advice to pre-existing programs in typical "after-the-fact" aspect-oriented style without fear they will break important data invariants used by the mainline code.In order to detect and enforce harmlessness, the paper defines a novel type and effect system related to information-flow type systems. The central technical result is that well-typed harmless advice does not interfere with the mainline computation. The paper also presents an implementation of the language and a case study using harmless advice to implement security policies.},
  booktitle = {the ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages = {383–396},
  numpages = {14},
  keywords = {noninterference, harmless advice, aspects, aspect-oriented},
  location = {Charleston, SC},
  series = {POPL '06},
  code = {https://github.com/dantasfiles/Harmless-Advice}
}

@inproceedings{10.1145/1086365.1086404,
  abbr = {ICFP},
  author = {Daniel Dantas and David Walker and Geoffrey Washburn and Stephanie Weirich},
  title = {PolyAML: a polymorphic aspect-oriented functional programming language},
  year = {2005},
  month = {sep},
  isbn = {1595930647},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1086365.1086404},
  html = {https://doi.org/10.1145/1086365.1086404},
  doi = {10.1145/1086365.1086404},
  abstract = {This paper defines PolyAML, a typed functional, aspect-oriented programming language. The main contribution of Poly<SMALL>AML</SMALL> is the seamless integration of polymorphism, run-time type analysis and aspect-oriented programming language features. In particular, Poly<SMALL>AML</SMALL> allows programmers to define type-safe polymorphic advice using pointcuts constructed from a collection of polymorphic join points. Poly<SMALL>AML</SMALL> also comes equipped with a type inference algorithm that conservatively extends Hindley-Milner type inference. To support first-class polymorphic point-cut designators, a crucial feature for developing aspect-oriented profiling or logging libraries, the algorithm blends the conventional Hindley-Milner type inference algorithm with a simple form of local type inference.We give our language operational meaning via a type-directed translation into an expressive type-safe intermediate language. Many complexities of the source language are eliminated in this translation, leading to a modular specification of its semantics. One of the novelties of the intermediate language is the definition of polymorphic labels for marking control-flow points. These labels are organized in a tree structure such that a parent in the tree serves as a representative for all of its children. Type safety requires that the type of each child is less polymorphic than its parent type. Similarly, when a set of labels is assembled as a pointcut, the type of each label is an instance of the type of the pointcut.},
  booktitle = {the ACM SIGPLAN International Conference on Functional Programming},
  pages = {306–319},
  numpages = {14},
  keywords = {type systems, type inference, functional programming, aspects-oriented programming, ad-hoc polymorphism},
  location = {Tallinn, Estonia},
  series = {ICFP '05},
  code = {https://github.com/dantasfiles/PolyAML}
}

@inproceedings{fool2005,
  abbr = {FOOL},
  author = {Daniel Dantas and David Walker},
  title = {Harmless advice},
  year = {2005},
  month = {jan},
  booktitle = {the ACM SIGPLAN Workshop on Foundations of Object-Oriented Languages},
  abstract = {This work-in-progress report develops a simple object calculus with harmless aspect-oriented advice. A piece of harmless advice is a computation that, like ordinary aspect-oriented advice, executes when control reaches a designated control-flow point. However, unlike ordinary advice, harmless advice is designed to obey a weak non-interference property. Harmless advice may change the termination behavior of computations and use I/O, but it does not otherwise influence the final result of computations that trigger it. A simple type and effect system related to information-flow type systems helps enforce harmlessness.},
  location = {Long Beach, CA},
  html = {https://homepages.inf.ed.ac.uk/wadler/fool/program/6.html}
}

@article{10.1145/509526.509528,
  abbr = {OSR},
  author = {Rimon Barr and John Bicket and Daniel Dantas and Bowei Du and T. W. Danny Kim and Bing Zhou and Emin Gun Sirer},
  title = {On the need for system-level support for ad hoc and sensor networks},
  year = {2002},
  issue_date = {April 2002},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {36},
  number = {2},
  issn = {0163-5980},
  url = {https://doi.org/10.1145/509526.509528},
  html = {https://doi.org/10.1145/509526.509528},
  doi = {10.1145/509526.509528},
  abstract = {Ad hoc and sensor networks are an important, emerging niche that is poorly supported by existing operating systems. In this paper, we argue that network-wide energy management is a primary concern in ad hoc networks, and that this functionality is best provided by a systems layer. We are currently designing and implementing a distributed, power-aware, adaptive operating system, called MagnetOS, specifically targeting ad hoc and sensor networks. MagnetOS provides a single system image of a unified Java virtual machine across the nodes that comprise an ad hoc network. By automatically and transparently partitioning applications into components and dynamically placing these components on nodes within the ad hoc network, our system reduces energy consumption, avoids hotspots and increases system longevity. We show that a systems approach to automatic object placement in an ad hoc network can increase system longevity by a factor of four to five.},
  journal = {ACM SIGOPS Operating Systems Review},
  month = {apr},
  pages = {1–5},
  numpages = {5}
}
